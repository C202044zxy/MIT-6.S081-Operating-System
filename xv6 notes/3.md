## 3.1 Paging hardware

The RISC-V page table hardware maps each virtual address to a physical address.

xv6 runs on Sv39 RISC-V, which means that only the bottom 39 bits of a 64-bit virtual address are used. The page table is logically an array of $2^{27}$ *page table entries* (PTEs). Each PTE contains a 44-bit physical page number (PPN) and some flags. 

A page table gives the operating system control over virtual-to-physical translations at the granularity of 4096 bytes. Such chunk is called a *page*.

<img src="picutres\3.png" width = 800>

Figure 3.1 demonstrates the logical process of translating a virtual address to a physical address (the page table is a simple array of PTEs). 

The real architecture of page table is far more complex for this. A page table is stored in physical memory as a three-level tree. The root of the tree is a 4096-byte page-table page containing 512 PTEs. Each PTE contains the physical address to page-table page in the next level of the tree.

If any of the three PTEs required to translate an address is not present, the paging hardware raises a page-fault exception, leaving it up to kernel to handle.

To avoid the cost of loading PTEs from physical memory, a RISC-V CPU caches page table entries in a *Translation Look-aside Buffer (TLB)*.

<img src="picutres\4.png" width = 600>

As shown in Figure 3.2, each PTE contains flag bits that tell the paging hardware how the associated virtual address is allowed to be used.

To tell the hardware to use page table, the kernel must write the physical address of root page-table page into the `satp` register. Each CPU has it own `satp`. A CPU will translate all addresses generated by subsequent instruction using page table pointed by its own `satp`.

## 3.2 Kernel address space

The kernel gets at RAM using direct-mapping. That is, mapping the resources at virtual addresses that are equal to the physical addresses. For example, the kernel itself is located at `KERNBASE=0x80000000` in both the virtual memory space and in physical memory.

<img src="picutres\5.png" width = 700>

There are a couple of kernel virtual addresses that aren't direct-mapped:

- The trampoline page. It is mapped at the top of the virtual address space. User page tables have this same mapping. 
- The kernel stack pages. Each process has it own kernel stack, which is mapped high so that below it xv6 can leave an unmapped *guard page*. The guard page's PTE is invalid, so that if the kernel overflows a kernel stack, it will likely cause an exception and the kernel will panic. 

## 3.3 Code: creating an address space

The central data structure is `pagetable_t`, which is really a pointer to a RISC-V root page-table page. A `pagetable_t` may be either the kernel page table, or one of the per-process page tables. The central functions are `walk`, which finds the PTE for a virtual address, and `mappages`, which installs PTEs for new mappings. 

```c++
// Create PTEs for virtual addresses starting at va that refer to
// physical addresses starting at pa. va and size might not
// be page-aligned. Returns 0 on success, -1 if walk() couldn't
// allocate a needed page-table page.
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
{
  uint64 a, last;
  pte_t *pte;
	// empty mapping not allowed
  if(size == 0)
    panic("mappages: size");
  // page-aligned
  a = PGROUNDDOWN(va);
  last = PGROUNDDOWN(va + size - 1);
  for(;;){
    // locate the PTE in pagetable
    // allocate new PTE along the way
    if((pte = walk(pagetable, a, 1)) == 0)
      return -1;
    // remapping not allowed
    if(*pte & PTE_V)
      panic("mappages: remap");
    // #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
    // extra PPN in physical address and put it into PTE
    // add perm flags and valid flag
    *pte = PA2PTE(pa) | perm | PTE_V;
    if(a == last)
      break;
    // move onto the next page
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
```

```c++
// Return the address of the PTE in page table pagetable
// that corresponds to virtual address va.  If alloc!=0,
// create any required page-table pages.
//
// The risc-v Sv39 scheme has three levels of page-table
// pages. A page-table page contains 512 64-bit PTEs.
// A 64-bit virtual address is split into five fields:
//   39..63 -- must be zero.
//   30..38 -- 9 bits of level-2 index.
//   21..29 -- 9 bits of level-1 index.
//   12..20 -- 9 bits of level-0 index.
//    0..11 -- 12 bits of byte offset within the page.
pte_t *
walk(pagetable_t pagetable, uint64 va, int alloc)
{
  if(va >= MAXVA)
    panic("walk");
	// traverse through intermediate page
  for(int level = 2; level > 0; level--) {
    // PX extra 9 bits of level-2 / level-1 index
    pte_t *pte = &pagetable[PX(level, va)];
    // PTE has already existed
    if(*pte & PTE_V) {
      // PTE contains the physical address (in its PPN)
      // to page-table page in the next level of the tree 
      pagetable = (pagetable_t)PTE2PA(*pte);
    } else {
      // if alloc = 1, allocate the PTE in the next level
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
        return 0;
      memset(pagetable, 0, PGSIZE);
      // save the physical address to the PPN in PTE
      *pte = PA2PTE(pagetable) | PTE_V;
    }
  }
  return &pagetable[PX(0, va)];
}
```

## 3.4 Physical memory allocation

xv6 uses the physical memory between the end of the kernel and `PHYSTOP` for run-time allocation. It allocates and frees whole 4096-byte pages at a time. It keeps track of which pages are freed by threading a linked list through the pages themselves. 

## 3.5 Process address space

Page tables are beneficial:

1. Different processes' page tables translate user addresses to different pages of physical memory, so that each process has private user memory. 
2. Each process sees its memory as having continuous virtual addresses, while the process's physical memory can be non-continuous. 
3. The kernel maps a page with trampoline code at the top of user address space, thus a single page of physical memory shows up in all address spaces. 

<img src="picutres\6.png" width = 500>

As shown in Figure 3.4, the process's user memory starts at virtual address zero and can grow up to MAXVA. If the user stack overflows and the process tries to use an address below the stack, the hardware will generate a page-fault exception because the guard page is inaccessible to a program running in user mode. 

